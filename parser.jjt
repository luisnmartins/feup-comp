options {
	MULTI = true;
	DEBUG_PARSER = false;
}

PARSER_BEGIN(parser)

	import java.io.*;
	public class parser{

		public static void main(String[] args) {
			String everything;
			
            parser xparser;
            
			
			if(args.length == 0){
				System.out.println("Parser, reading the input...");
				xparser = new parser(System.in);
			}else if(args.length == 1){
				System.out.println("Parser: Reading the file " + args[0]);
				try{
					xparser = new parser(new java.io.FileInputStream(args[0]));
				}catch(java.io.FileNotFoundException e){
					System.out.println("Parser, The file" + args[0] + "was not found");
					return;

				}
			}else{
				System.out.println ("Parser:  You must use one of the following:");
        		System.out.println ("         java parser < file");
        		System.out.println ("Or");
        		System.out.println ("         java parser file");
        		return ;
			}try {
                SimpleNode root = xparser.module();
                root.dump("");
				
			}catch(ParseException e){
				System.out.println ("Parser: There was an error during the parse.");
				System.out.println (e.getMessage());
			}
			catch(TokenMgrError e){
				System.out.println ("Parser: There was an error.");
				System.out.println (e.getMessage());
			}
		}
		
	/*	public int eval(SimpleNode node){
			if(node.jjtGetNumChildren() == 0)
            		return node.val;
        	else if(node.jjtGetNumChildren() == 1)
            		return this.eval((SimpleNode) node.jjtGetChild(0));
			SimpleNode[] children = new SimpleNode[node.jjtGetNumChildren()];

			for(int i = 0; i < node.jjtGetNumChildren(); i++){
				children[i] = (SimpleNode) node.jjtGetChild(i);
			}

			switch (node.id) {
				case value:
					
					break;
			
				default:
					break;
			}

			return 0;
		}*/
	}


PARSER_END(parser)

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
| <ADDSUB_OP: "+" | "-">
| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
| <BITWISE_OP: "&" | "|" | "^">
| <NOT_OP: "!">
| <WHILE: "while">
| <IF: "if">
| <ELSE: "else">
| <ASSIGN: "=">
| <ASPA: "\"">
| <LPAR: "(">
| <RPAR: ")">
| <VIRG: ",">
| <PVIRG: ";">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <FUNCTION: "function">
| <MODULE: "module">
| <SIZE: "size">
}

TOKEN : {
<INTEGER: (<DIGIT>)+>
| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
| <#DIGIT: ["0"-"9"]>
| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}


JAVACODE
void error_skipto(int kind, ParseException e) {
	
	System.out.println(e.toString());
	Token t;
	do{
		t=getNextToken();
	}while(t.kind != kind);
}

JAVACODE 
void error_skipto2(int kind, int kind2, ParseException e) { 
   
  System.out.println(e.toString()); 
  Token t; 
  do{ 
     
    t=getNextToken(); 
    System.out.println(t); 
 
  }while(t.kind != kind && t.kind != kind2); 

  /**
   *  //try { 
    <MODULE> <ID> <LCHAVETA> (Declaration())* ( 
        { 
          while(jj_ntk != RCHA) 
            try { 
              Function() 
            } ... 
        } 
        <RCHAVETA> 
        LOOKAHEAD({!}) 
        try { 
          Function() 
        } catch(ParseException e) { 
          error_skipto(PVIRG, e); 
        } 
      )* <RCHAVETA> 
  /*} catch(ParseException e) { 
    error_skipto(RCHAVETA, e); }
   */
}


SimpleNode module(): {Token t;}  
{
	try {
		<MODULE> t=<ID> {jjtThis.moduleName = t.image;} <LCHAVETA> (Declaration())* (Function())* <RCHAVETA> 
	} catch (ParseException e) {
		error_skipto(RCHAVETA, e);
	} 
	{return jjtThis;}
}

void Declaration() : {}
{
	access() ( (<ASSIGN> #equals) (("[" ArraySize() "]" #arrayDeclaration) | ( (<ADDSUB_OP>)? <INTEGER> #scalarDeclaration)) )? <PVIRG>
}

void Function() : {Token t;}
{
	try{
	<FUNCTION> t=<ID> {jjtThis.moduleName = t.image;} 
	}catch(ParseException e){
		
		error_skipto(ID, e);
	}
	try{
	( ( ("[" "]")? <ASSIGN> <ID> <LPAR> (Varlist())? <RPAR> ) | (<LPAR> ( Varlist() )? <RPAR> ) )
		
	}catch(ParseException e){
		
		error_skipto(RPAR, e);
	}
	
		<LCHAVETA> Stmtlst() <RCHAVETA>
	
	
}

void access() #void :{}
{
	<ID> (ArrayElement() | {} #scalar)
}

void Varlist() #void : {}
{
	access() ( <VIRG> access())*
}

void ArrayElement() #array : {}
{
	"[" "]"
}


void Stmtlst() #void : {}
{
	 ( Stmt() )*
	 
}

void Stmt() #void : {}
{
	
	While() 
	| 
	If() 
	| 
	try{	
		(( <ID> (LOOKAHEAD(2) Call() | Assign() )) <PVIRG>)
	}catch(ParseException e){
		
		error_skipto(PVIRG, e);
	}


	
}


void Call() : {}
{
	try{
		( "." <ID> )? <LPAR> ( ArgumentList() )? <RPAR>
	}catch(ParseException e){
		error_skipto(RPAR, e);
	}
	
	
}


void Assign() : {}
{
	Lhs() <ASSIGN> Rhs()
}

void Lhs() : {}
{
	ArrayAccess() | ScalarAccess()
}

void Rhs() : {}
{
	( Term() ( ( <ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP> ) Term() )? )
		| "[" ArraySize() "]"

}

void ArraySize() : {}
{
	( <ID> ScalarAccess() ) | <INTEGER>
}

void Term() : {}
{
	( <ADDSUB_OP> )? ( <INTEGER> | ( <ID> ( ArrayAccess() | (LOOKAHEAD(2) Call() | ScalarAccess()))))
}

void Exprtest() : {}
{
	try{
	<LPAR> <ID> Lhs() <RELA_OP> Rhs() <RPAR>
	}catch(ParseException e){
		
		error_skipto(RPAR, e);
	}
}

void While() : {}
{
	try{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
	}catch(ParseException e){
		error_skipto(RCHAVETA, e);
	}
}

void If() : {}
{
	try{
		<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> ( <ELSE> <LCHAVETA> Stmtlst() <RCHAVETA> )?
	}catch(ParseException e){
		error_skipto(RCHAVETA, e);
	}
}

void ArgumentList() : {}
{
	
	Argument() ( <VIRG> Argument() )*
	
	
}

void Argument() : {}
{
	( <ID> | <STRING> | <INTEGER> )
}

void ArrayAccess() : {}
{
	"[" Index() "]"
}

void ScalarAccess() : {}
{
	( "." <SIZE> )?
}

void Index() : {}
{
	<ID> | <INTEGER>
}
