
import java.util.ArrayList;
import java.util.AbstractMap.SimpleEntry;

/* Generated By:JJTree: Do not edit this line. ASTAssign.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTAssign extends SimpleNode {

  public ASTAssign(int id) {
    super(id);
  }

  public ASTAssign(Parser p, int id) {
    super(p, id);
  }

  // Assign ( = )
  @Override
  public String toString(String prefix) {
    return prefix + " " + toString() + " ( = ) ";
  }

  @Override
  public SimpleEntry<Boolean, Boolean> createAndCheckSymbol(SymbolTable parent) throws ParseException {

    ASTAccess leftSide = (ASTAccess) this.jjtGetChild(0);
    Symbol newVar = parent.getFromAll(leftSide.name);
    Boolean isLeftArray = false;
    Boolean isIndex = false;
    if (leftSide.jjtGetNumChildren() > 0) {
      if (!leftSide.jjtGetChild(0).createAndCheckSymbol(parent).getKey()) {
        return new SimpleEntry<>(false, null);
      }
      isIndex = true;
      isLeftArray = false;
    } else {
      if (newVar != null)
        isLeftArray = newVar.isArray();
    }

    if (leftSide.isSize) {
      throw new ParseException(this, "It is not possible to change array size");
    }

    if (this.jjtGetChild(1) != null) {

      SimpleEntry<Boolean, Boolean> rhs = null;
      try {
        rhs = this.jjtGetChild(1).createAndCheckSymbol(parent);
      } catch (ParseException e) {
        System.out.println(e.getMessage());
        return new SimpleEntry<>(false, null);
      }
      if (rhs.getKey() == false) {
        return new SimpleEntry<>(false, null);
      } else {
        if (rhs.getValue() == null) {
          throw new ParseException(this,
              "Variable " + leftSide.name + " will not be assigned according to the right side");

        }
        if (newVar != null) {

          if (isLeftArray) {
            if (!rhs.getValue() && !newVar.isInitialized()) {
              throw new ParseException(this,
                  "Array " + leftSide.name + " can't be filled since it has no size specified");

            }
            newVar.setInitialized(true);

          } else {
            if (isLeftArray != rhs.getValue()) {
              throw new ParseException(this,
                  "Variable " + leftSide.name + " is not compatible with the right side value");
            }
            // a; a=[100];
            if (!newVar.isInitialized() && rhs.getValue()) {
              throw new ParseException(this, "Variable " + leftSide.name + "can not be initialized as an array");

            }
            // Freshly added
            if (isIndex && !newVar.isInitialized()) {
              throw new ParseException(this,
                  "Can't access variable " + leftSide.name + " with an index since it is not an array");
            }
            newVar.setInitialized(true);

          }

        } else {

          if (isIndex) {
            throw new ParseException(this,
                "Can't access variable " + leftSide.name + " with an index since it is not an array");

          }
          Symbol addedVariable = parent.pushVariable(leftSide.name, rhs.getValue(), true);

        }
      }
    }

    return new SimpleEntry<>(true, null);
  }

  @Override
  public int setRegistry(FunctionTable parent, int registry) {
    int reg = registry;

    reg = this.jjtGetChild(0).setRegistry(parent, reg);

    return reg;

  }

  public ArrayList getJVMCode(FunctionTable parent, ArrayList instList) {
    ArrayList instructions = instList;

    ASTAccess access = (ASTAccess) this.jjtGetChild(0);

    String module_name = parent.getParent().getModuleName();

    Symbol symbol = parent.getFromScope(access.name);

    Boolean accessGlobal = false;


    if (symbol == null) {
      accessGlobal = true;
      symbol = parent.getFromAll(access.name);
    }

    instructions = this.jjtGetChild(1).getJVMCode(parent, instructions);

    if (symbol.isArray()) {
      if (access.jjtGetNumChildren() > 0) {
        
        int maxReg = parent.getMaxRegistry();
        maxReg++;
        instructions.add("istore " + maxReg);

        parent.setMaxRegistry(maxReg);

        // a[...] = ...

        if (accessGlobal)
          instructions.add("getstatic " + module_name + "/" + access.name + " [I");
        else
          instructions.add("aload " + symbol.getRegistry());

        // METER AKI O INDEX
        instructions = access.jjtGetChild(0).getJVMCode(parent, instructions);

        instructions.add("iload " + maxReg);
        instructions.add("iastore");
        instructions.add("");

      } else {

        if ((this.jjtGetChild(1).jjtGetNumChildren() == 1
            && this.jjtGetChild(1).jjtGetChild(0) instanceof ASTArraySize) || access.isSize) {
          // a = [2]; ou a.size = [2]
          if (accessGlobal)
            instructions.add("putstatic " + module_name + "/" + access.name + " [I");
          else
            instructions.add("astore " + symbol.getRegistry());

          instructions.add("");


        } else {
          int maxReg = parent.getMaxRegistry();
          int value = 0;

          Boolean rhs_access_is_array = false;
          Boolean accessRhsGlobal = false;
          Symbol rhs_access_symbol = null;
          ASTAccess rhs_access = null;

          if(this.jjtGetChild(1).jjtGetChild(0).jjtGetNumChildren() > 0){
            // array = algo sem ser integer

            if(this.jjtGetChild(1).jjtGetChild(0).jjtGetChild(0) instanceof ASTAccess){
              rhs_access = (ASTAccess) this.jjtGetChild(1).jjtGetChild(0).jjtGetChild(0);
              rhs_access_symbol = parent.getFromScope(rhs_access.name);
              
              
              if (rhs_access_symbol == null) {
                accessRhsGlobal = true;
                rhs_access_symbol = parent.getFromAll(rhs_access.name);
              }

              if(rhs_access_symbol.isArray()){
                rhs_access_is_array = true;
              }
            }
          }
          int iterator_rhs_access = 0;

          maxReg++;
          // a = value, logo fill the array

          value = maxReg;

          if(rhs_access_is_array){
            maxReg++;

            iterator_rhs_access = maxReg;

            if (accessRhsGlobal) {
            instructions.add("getstatic " + module_name + "/" + rhs_access.name + " [I");
          } else {
            instructions.add("aload " + rhs_access_symbol.getRegistry());
          }
          instructions.add("arraylength");

            instructions.add("newarray int");

            if (accessGlobal)
              instructions.add("putstatic " + module_name + "/" + access.name + " [I");
            else
              instructions.add("astore " + symbol.getRegistry());


          }else{
            instructions.add("istore " + value);
            // a = value, logo fill the array

          }

                    

          if (accessGlobal) {
            instructions.add("getstatic " + module_name + "/" + access.name + " [I");
          } else {
            instructions.add("aload " + symbol.getRegistry());
          }
          instructions.add("arraylength");

          maxReg++;

          int size = maxReg;

          maxReg++;

          int iterator = maxReg;

          parent.setMaxRegistry(maxReg);

          int loopCount = getLoopCount(instructions);


          instructions.add("istore " + size);
          instructions.add("iconst_0");
          instructions.add("istore " + iterator); // cria variavel para o iterador do loop de inicializacao

          if(rhs_access_is_array){
            instructions.add("iconst_0");
            instructions.add("istore " + iterator_rhs_access); // cria variavel para o iterador do loop de inicializacao
          }

          instructions.add("loop" + loopCount + ":");

          instructions.add("iload " + iterator);
          instructions.add("iload " + size);

          instructions.add("if_icmpge loop_end" + loopCount);

          if (rhs_access_is_array) {
            if (accessRhsGlobal) {
              instructions.add("getstatic " + module_name + "/" + rhs_access.name + " [I");
            } else {
              instructions.add("aload " + rhs_access_symbol.getRegistry());
            }
            instructions.add("iload " + iterator_rhs_access);

            instructions.add("iaload"); 

            instructions.add("istore " + value);

          }

          if (accessGlobal) {
            instructions.add("getstatic " + module_name + "/" + access.name + " [I");
          } else {
            instructions.add("aload " + symbol.getRegistry());
          }
          instructions.add("iload " + iterator);

          
          instructions.add("iload " + value);
          
          
          instructions.add("iastore");

          instructions.add("iinc " + iterator + " 1");

          if(rhs_access_is_array)
            instructions.add("iinc " + iterator_rhs_access + " 1");

          instructions.add("goto loop" + loopCount);

          instructions.add("loop_end" + loopCount + ":");

          instructions.add("");

        }

      }

    } else {
      if (accessGlobal)
        instructions.add("putstatic " + module_name + "/" + access.name + " I");
      else
        instructions.add("istore " + symbol.getRegistry());

      instructions.add("");
    }

    return instructions;
  }

}
/*
 * JavaCC - OriginalChecksum=707623fe908a83fd2745ed78935babb9 (do not edit this
 * line)
 */
