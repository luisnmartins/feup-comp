
import java.util.ArrayList;
import java.util.AbstractMap.SimpleEntry;


/* Generated By:JJTree: Do not edit this line. ASTAssign.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTAssign extends SimpleNode {

  public ASTAssign(int id) {
    super(id);
  }

  public ASTAssign(Parser p, int id) {
    super(p, id);
  }

  //Assign ( = )
  @Override
  public String toString(String prefix) {
    return prefix + " "+ toString() + " ( = ) ";
  } 
  
  @Override
  public SimpleEntry<Boolean,Boolean> createAndCheckSymbol(SymbolTable parent) throws ParseException {
    
    ASTAccess leftSide = (ASTAccess) this.jjtGetChild(0);
    Symbol newVar = parent.getFromAll(leftSide.name);
    Boolean isLeftArray = false;
    Boolean isIndex = false;
    if(leftSide.jjtGetNumChildren() > 0){
      if(!leftSide.jjtGetChild(0).createAndCheckSymbol(parent).getKey()){
        return new SimpleEntry<>(false,null);
      }
      isIndex = true;
      isLeftArray = false;
    }else{
      if(newVar != null)
      isLeftArray = newVar.isArray();
    }

    if(leftSide.isSize){
      throw new ParseException(this, "It is not possible to change array size");
    }
  

    if(this.jjtGetChild(1) != null) {

      SimpleEntry<Boolean,Boolean> rhs = null;
      try {
        rhs = this.jjtGetChild(1).createAndCheckSymbol(parent);
      }catch(ParseException e) {
        System.out.println(e.getMessage());
        return new SimpleEntry<>(false, null);
      }
      if(rhs.getKey() == false) {
        return new SimpleEntry<>(false, null);
      }
      else {
        if(rhs.getValue() == null){
          throw new ParseException(this, "Variable "+leftSide.name+" will not be assigned according to the right side");

        }
        if(newVar != null) {

          if(isLeftArray) {
            if(!rhs.getValue() && !newVar.isInitialized()) {
              throw new ParseException(this, "Array " + leftSide.name + " can't be filled since it has no size specified");

            }
            newVar.setInitialized(true);

          } else {
              if(isLeftArray != rhs.getValue()){
                throw new ParseException(this, "Variable " + leftSide.name + " is not compatible with the right side value");
              }
              //a; a=[100];
              if(!newVar.isInitialized() && rhs.getValue()) {
                throw new ParseException(this, "Variable "+leftSide.name + "can not be initialized as an array");

              }
              //Freshly added
              if(isIndex && !newVar.isInitialized()){
                throw new ParseException(this, "Can't access variable " + leftSide.name +" with an index since it is not an array");
              }
              newVar.setInitialized(true);
          
          }
        
        } else { 
          
         if(isIndex){
           throw new ParseException(this, "Can't access variable " + leftSide.name +" with an index since it is not an array");

         }
          Symbol addedVariable = parent.pushVariable(leftSide.name, rhs.getValue(), true);

        }
      }
    }

    return new SimpleEntry<>(true,null);
  }

  @Override
  public int setRegistry(FunctionTable parent, int registry) {
    int reg = registry;

    reg = this.jjtGetChild(0).setRegistry(parent, reg);

    return reg;

  }

  public ArrayList getJVMCode(FunctionTable parent, ArrayList instList) {
    ArrayList instructions = instList;

    instructions = this.jjtGetChild(1).getJVMCode(parent, instructions);

    return instructions;
  }

}
/* JavaCC - OriginalChecksum=707623fe908a83fd2745ed78935babb9 (do not edit this line) */
