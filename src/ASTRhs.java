import java.util.ArrayList;
import java.util.AbstractMap.SimpleEntry;

/* Generated By:JJTree: Do not edit this line. ASTRhs.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public
class ASTRhs extends SimpleNode {

  public String operator = null;

  public ASTRhs(int id) {
    super(id);
  }

  public ASTRhs(Parser p, int id) {
    super(p, id);
  }

  //Rhs(+/-/*..)
  @Override
  public String toString(String prefix) {
    if(this.operator != null)
      return prefix + " " + toString()+ " ( "+ this.operator + " )";
    else
      return prefix + " " + toString();
  }

  @Override
  public SimpleEntry<Boolean,Boolean> createAndCheckSymbol(SymbolTable parent) throws ParseException{

    Boolean allCorrect = true;
    SimpleEntry<Boolean, Boolean> response = new SimpleEntry<>(true, false);
    for(int i=0; i<this.jjtGetNumChildren(); i++) {
      try {
        response = this.jjtGetChild(i).createAndCheckSymbol(parent);
      } catch(ParseException e) {
        allCorrect = false;
        response = new SimpleEntry<>(false, false);
        System.out.println(e.getMessage());
      }
      if(operator != null && response.getValue() == true) {
        throw new ParseException(this, "Is not possible to operate with arrays");
      }
    }
    if(allCorrect == false)
      return new SimpleEntry<>(false, null);
    else
      return new SimpleEntry<>(true, response.getValue());
  }

  public ArrayList getJVMCode(FunctionTable parent, ArrayList instList) {
    ArrayList instructions = instList;

    String module_name = parent.getParent().getModuleName();

    ASTAccess access = (ASTAccess) this.parent.jjtGetChild(0);

    Symbol symbol = parent.getFromScope(access.name);

    Boolean accessGlobal = false;

    if (symbol == null) {
      accessGlobal = true;
      symbol = parent.getFromAll(access.name);
    }

    if (symbol.isArray()) {
      // ARRAY
    } else {
      if (children.length == 1) {
        // Term is +/- INTEGER

        ASTTerm term = (ASTTerm) children[0];
        String value = term.getValueSigned();
        if (value != "") {
          instructions.add("bipush " + value);
          // countStack = setStackCounter(countStack, 1);
        } else {
          instructions = term.getJVMCode(parent, instructions);
        }

      } else {
        for (int m = 0; m < 2; m++) {
          ASTTerm term = (ASTTerm) children[m];
          String value = term.getValueSigned();

          if (value != "") {
            instList.add("bipush " + value);
          } else {
            instructions = term.getJVMCode(parent, instructions);
          }
        }
        instList.add(getOperation(operator));
      }

      if (accessGlobal)
        instructions.add("putstatic " + module_name + "/" + access.name + " I");
      else
        instructions.add("istore " + symbol.getRegistry());

      instructions.add("");
    }

    return instructions;
  }

  public String getOperation(String op) {
    switch (op) {
    case "+":
      return "iadd";
    case "-":
      return "isub";
    case "*":
      return "imul";
    case "/":
      return "idiv";
    case "<<":
      return "ishl";
    case ">>":
      return "ishr";
    case ">>>":
      return "iushr";
    case "&":
      return "iand";
    case "|":
      return "ior";
    case "^":
      return "ixor";
    default:
      return "";
    }
  }

}
/* JavaCC - OriginalChecksum=243722291f580c9eef839a742207993d (do not edit this line) */
