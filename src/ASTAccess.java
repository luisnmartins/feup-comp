import java.util.ArrayList;
import java.util.AbstractMap.SimpleEntry;

import javax.sound.midi.SysexMessage;

/* Generated By:JJTree: Do not edit this line. ASTAccess.java Version 4.3 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
public class ASTAccess extends SimpleNode {

  public String name;
  public Boolean isSize = false; // Variable that checks if it is has an arrayAccess, and if it does, ".size" is
                                 // added to the string

  public ASTAccess(int id) {
    super(id);
  }

  public ASTAccess(Parser p, int id) {
    super(p, id);
  }

  // Access(variable.size) or Access(variable)
  @Override
  public String toString(String prefix) {
    if (isSize) {
      return prefix + " " + toString() + " ( " + this.name + ".size ) ";
    } else {
      return prefix + " " + toString() + " ( " + this.name + " ) ";
    }
  }

  @Override
  public SimpleEntry<Boolean, Boolean> createAndCheckSymbol(SymbolTable parent) throws ParseException {
    boolean hasIndex = false;
    for (int i = 0; i < jjtGetNumChildren(); i++) {
      hasIndex = true;
      if (!jjtGetChild(i).createAndCheckSymbol(parent).getKey()) {
        return new SimpleEntry<>(false, null);
      }

    }
    Symbol access;
    if ((access = parent.getFromAll(name)) == null) {
      throw new ParseException(this, "Variable " + name + " doesn't exist");
    } else {
      if (!access.isInitialized()) {
        throw new ParseException(this, "Variable " + name + " insn't initialized");
      }

      if (hasIndex && !access.isArray()) {
        throw new ParseException(this, "Can't access variable " + name + " with an index since it is not an array");
      }

      if (isSize && !access.isArray()) {
        throw new ParseException(this, "Can't get variable " + name + " size since it is not an array");
      }

    }
    if (hasIndex || isSize)
      return new SimpleEntry<>(true, false);
    else
      return new SimpleEntry<>(true, access.isArray());
  }

  @Override
  public int setRegistry(FunctionTable parent, int registry) {
    int reg = registry;
    Symbol symbol = parent.hasRegistry(name);
    if (symbol != null) {
      symbol.setRegistry(reg);
      reg++;
    } else {
      SimpleEntry<String, Symbol> symbolEntry = parent.getReturnParameter();
      if (symbolEntry != null && !parent.getRetHasReg()) {
        symbol = symbolEntry.getValue();
        if (!symbol.isRegistered()) {
          symbol.setRegistry(reg);
          reg++;

        }
      }
    }

    return reg;

  }

  @Override
  public int setRegistry(FunctionTable parent, FunctionTable parent2, int registry) {
    
    int reg = registry;
    Symbol symbol = parent.hasRegistry(name);
    if (symbol != null) {
      symbol.setRegistry(reg);
      reg++;
    } else {
      SimpleEntry<String, Symbol> symbolEntry = parent.getReturnParameter();
      if (symbolEntry != null && !parent.getRetHasReg()) {
        symbol = symbolEntry.getValue();
        if (!symbol.isRegistered()) {
          symbol.setRegistry(reg);
          reg++;

        }
      }
    }

    return reg;

  }

  public ArrayList getJVMCode(FunctionTable parent, ArrayList instList) {
    ArrayList instructions = instList;

    String module_name = parent.getParent().getModuleName();

    Symbol symbol = parent.getFromScope(name);
    Boolean accessGlobal = false;
    if (symbol == null) {
      accessGlobal = true;
      symbol = parent.getFromAll(name);
    }

    if (this.jjtGetNumChildren() > 0) {
      // x = a[2];
      if (accessGlobal)
        writeToFile("getstatic " + module_name + "/" + name + " [I", module_name);
      else
        writeToFile(getInstWihUnderscore("aload", symbol.getRegistry()), module_name);

      jjtGetChild(0).getJVMCode(parent, instructions);

      setMaxStack(jjtGetChild(0).getMaxStack() + 1);

      writeToFile("iaload", module_name);

    } else {

      if (symbol.isArray()) {
        // a = [10]; b = a; ou x = a.size;

        if (isSize) {
          // x = a.size;

          if (accessGlobal) {
            writeToFile("getstatic " + module_name + "/" + name + " [I", module_name);
          } else {
            writeToFile(getInstWihUnderscore("aload", symbol.getRegistry()), module_name);
          }
          writeToFile("arraylength", module_name);

        } else {

          

          // a = [10]; b = a;

        }

      } else {
        // x = a;

        if (accessGlobal)
          writeToFile("getstatic " + module_name + "/" + name + " I", module_name);
        else{
          writeToFile(getInstWihUnderscore("iload", symbol.getRegistry()), module_name);
          
        }
          
        // countStack = setStackCounter(countStack, 1);

      }

      setMaxStack(1);

      

    }

    System.out.println("ACCESS MAX: " + getMaxStack());



    return instructions;

  }
}
/*
 * JavaCC - OriginalChecksum=4ba1678d017435dc0581d9f0bda7fe02 (do not edit this
 * line)
 */
